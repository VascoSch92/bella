""" Functions and classes specifically modelling Riley groups.
"""

import numpy as np
from . import cayley
from . import farey
import functools

class RileyGroup(cayley.GroupCache):
    """ Represents a Riley group.

        A Riley group is a subgroup of PSL(2,C) generated by the matrices X = [[α,1],[0,α*]] and Y = [[β,0],[μ,β*]]
        where α and β are respectively pth and qth roots of -1 and μ is a complex number. Hence X and Y are elliptic
        elements of respective order p and q, or (if p or q are infinite) parabolic elements. In words, x and y represent
        the inverses of X and Y respectively.

    """
    def __init__(self, p, q, μ):
        """ Construct the Riley group on generators of order p and q with parameter μ."""
        relations = []

        def generator(index, order):
            if order == np.inf:
                return 1
            else:
                relations.append((index,)*order)
                return np.exp(1j*np.pi/order)

        self.α = generator(0, p)
        self.β = generator(1, q)
        self.μ = μ
        X = np.array([[self.α,1],[0,np.conj(self.α)]])
        Y = np.array([[self.β,0],[self.μ,np.conj(self.β)]])

        super().__init__([X,Y], relations)
        self.generator_map = {'X':0, 'Y':1, 'x':self.gen_to_inv[0], 'y':self.gen_to_inv[1]}

    def string_to_word(self, s):
        """ Produce a word in the GroupCache sense from a string of letters out of X, Y, x, y. """
        return tuple(functools.reduce( (lambda x,y: x + (self.generator_map[y],)), s, tuple()))

    @functools.cache
    def farey_matrix(self, r, s):
        """ Return the r/s-Farey matrix in this group. """
        return self[self.string_to_word(farey.farey_string(r,s))]

    @functools.cache
    def farey_fixed_points(self, r, s):
        """ Return the fixed points of the r/s-Farey matrix in this group. """
        return self.fixed_points(self.farey_matrix(r,s))

    def guess_radial_coordinate(self, ε):
        """ Attempt to guess the Keen-Series coordinate of the group.

            More precisely, iterate over all possible r/s so that the Farey word
            W_r/s has real trace up to error `ε`.
        """
        for (r,s) in farey.walk_tree_bfs():
            v = farey.polynomial_evaluate(r, s, self.α, self.β, self.μ)
            if np.abs(np.imag(v)) < ε:
                return (r,s)
