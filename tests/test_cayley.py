import pytest
from bella import cayley
import mpmath as mp

def matrix_almosteq_up_to_sign(M,N):
    return matrix_almosteq(M,N) or matrix_almosteq(M,-N)

def matrix_almosteq(M,N):
    return mp.almosteq(M[0,0],N[0,0]) and mp.almosteq(M[1,0],N[1,0]) and mp.almosteq(M[0,1],N[0,1]) and mp.almosteq(M[1,1],N[1,1])\
      and M.rows == 2 and M.cols == 2 and N.rows == 2 and N.cols == 2

def test_generators_from_circle_inversions():
    circle_1 = (0, 1) # unit circle
    line_1 = (0, 1) # line through 0 and 1

    # For orthogonal reflections A and B, AB = (BA)^-1 since A and B commute.
    orthogonal_gens = cayley.generators_from_circle_inversions([circle_1], [line_1])
    assert matrix_almosteq_up_to_sign(orthogonal_gens[0] @ orthogonal_gens[0], mp.eye(2))

    circle_2 = (2+3j, 2)

    # Result of this should be [AB] where A is inversion in circle 1 and B is inversion in circle 2.
    gens1 = cayley.generators_from_circle_inversions([circle_1,circle_2], [])
    # Result of this should be [BA].
    gens2 = cayley.generators_from_circle_inversions([circle_2,circle_1], [])
    assert len(gens1)==1
    assert len(gens2)==1
    assert matrix_almosteq_up_to_sign(gens1[0] @ gens2[0], mp.eye(2))

    # More complicated. Let us take the group generated by inversions in circle_1 and circle_2.
    # The action of the generator AB should be to take any point outside circle_2 and move it into circle_1.
    projective_point = gens2[0] @ mp.matrix([[4+3j],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]
    projective_point = gens2[0] @ mp.matrix([[0],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]
    projective_point = gens2[0] @ mp.matrix([[1j],[1]])
    assert mp.fabs(projective_point[1]/projective_point[0] - circle_1[0]) < circle_1[1]


    circle_3 = (-3+0.001j, 0.4)
    lots_of_gens = cayley.generators_from_circle_inversions([circle_2,circle_1,circle_3], [line_1])
    assert len(lots_of_gens) == 4 # C2 C1, C1 C3, C3 L1, L1 C2


    # Now we test some geometry.
    line_2 = (0,1+1j) #45degree line
    rotgroup = cayley.generators_from_circle_inversions([], [line_2, line_1])
    #Generator of this group should be a rotation anticlockwise by 2*45=90 degrees.
    rot = mp.matrix([[1j,0],[0,1]])
    rot = 1/mp.sqrt(cayley.simple_det(rot)) * rot
    assert matrix_almosteq_up_to_sign(rotgroup[0], rot)

    line_3 = (0+2j, 1+1j+2j) # shift of line_2 up by 2j
    shiftgroup = cayley.generators_from_circle_inversions([], [line_3, line_2])
    #Generator of this group should be a translation by 2*2*cos(pi/4)*exp(i*3pi/4)
    shift = mp.matrix([[1,4*mp.cos(mp.pi/4)*mp.exp(3j*mp.pi/4)],[0,1]])
    assert matrix_almosteq_up_to_sign(shiftgroup[0], shift)

    # Take two tangent circles. Inversion in one times inversion in the other should be parabolic with fixed point
    # at the point of intersection.
    circle_4 = (2,1)
    parabolic_gens = cayley.generators_from_circle_inversions([circle_1,circle_4],[])
    G = cayley.GroupCache(parabolic_gens)
    assert cayley.simple_tr(G[(0,)])**2 == 4
    assert G.fixed_points((0,))[0] == 1

def test_basic_invariants():
    bad_det = mp.matrix([[1,2],[3,4]])
    with pytest.warns(cayley.NonUnitDeterminantWarning) as e_info:
        assert cayley.GroupCache([bad_det])
    λ = 2+3j
    X = mp.matrix([[λ,0],[0,λ**-1]])
    Y = mp.matrix([[-1j*(4+3j), -1j],[-1j, 0]])
    G = cayley.GroupCache([X,Y])
    assert len(G) == 2
    assert G[(0,)] == X
    assert G[(1,)] == Y
    assert matrix_almosteq(G[G.inv_word((0,))], X**-1)
    assert matrix_almosteq(G[G.inv_word((1,))], Y**-1)
    assert matrix_almosteq(G[(1,0)], Y*X)
    assert not G.is_reduced_from_left((0,) + G.inv_word((0,))) # Xx is not reduced
    assert G.is_reduced_from_left((0,) + G.inv_word((1,))) # Xy is reduced

def test_simple_matrix_formulae():
    X = mp.matrix([[1,2],[-3j,0.1]])
    assert cayley.simple_tr(X) == mp.mpf(1) + mp.mpf(0.1)
    assert cayley.simple_det(X) == 1*0.1 - 2*(-3j)
    assert cayley.simple_inv(X) == 1/(cayley.simple_det(X)) * mp.matrix([[0.1,-2],[3j,1]])
